---
title: Atomic Operation in C#.Net
categories:
  - Hack
tags:
  - Hack
permalink: Atomic-Operation-In-Csharp
---

<h3>Introduction</h3>
<p>Atomic Operation is named academic to <a href="http://en.wikipedia.org/wiki/Atomic_operation" target="_blank">Linearizability</a>,&nbsp;Atomicity is a guarantee of isolation from concurrent processes, it can be enfored by hardware level build on <a href="coherence" target="_blank">Cache&nbsp;Coherence</a> protocol, or software level exclusive lock. In this blog post, I am going to explore a few number of mechanisms to achieve atomic operation in .Net.</p>
<h3>What are Atomic operations and what are not?</h3>
<p>In <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf" target="_blank">C# Specification</a>, the stamement about atomic operation is:</p>
<blockquote>&ldquo;Reads and writes of the following data types shall be atomic: bool, char, byte, sbyte, short, ushort, uint, int, float, and reference types.&rdquo; Also: &ldquo;&hellip;there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&rdquo;.</blockquote>
<p><a href="http://www.albahari.com/threading/" target="_blank">Threading In C#</a>&nbsp;by Joseph Albahari described:</p>
<blockquote>"Read/write on a field of 32-bit or less is always atomic, operations on 64-bit are guaranteed to be atomic only in 64-bit OS, statements that combine more than one read/write operation are never atomic."</blockquote>
<p>For example, following operations are guaranteed to be atomic operations:</p>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">3</span>; <span style="color: #99968b; font-style: italic;">// Always atomic</span><br /> <span style="color: #cae682;">long</span> <span style="color: #f6f3e8;">l</span> <span style="color: #f6f3e8;">=</span> <span style="color: #f6f3e8;">Int64</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">MaxValue</span>; <span style="color: #99968b; font-style: italic;">// Atomic in 64-bit enviroment, non-atomic on 32-bit environment</span></pre>
<p>Code like below are never atomic:</p>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<br /> <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">j</span> <span style="color: #f6f3e8;">+=</span> <span style="color: #f6f3e8;">i</span>;&nbsp; <span style="color: #99968b; font-style: italic;">// Non-atomic, read and write operation</span><br /> <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #99968b; font-style: italic;">// Non-atomic, read and write operation</span></pre>
<p>And I am trying to document atomic operation in a lower level in the section below.</p>
<h3>Essence</h3>
<p>Comsidering two threads (or two processes) are running simultaneously: T1 and T2, there is a field stored in memory, T1 reads its value and do some calculation on the value and finally write the new value back to memory, during the period T2 was actually doing exact same task - i.e. read/calculate/write value back, so possibly one operation on this field <strong>overrides another</strong> - in other word:&nbsp;<strong>the later executed thread (T2) might override the earlier executed one (T1) because when it read the field's value another thread was just manipulating on it, and after T1 finished writing the new value back to memory, T2 writes back</strong>.</p>
<p>So a simple example is the increament/decrement operation, as I showed above, it is NOT an atomic operation, it requires both read and write, if many thread simultaneously doing increment on one field, it will very possible cause race condition (<strong>the more threads, the more increment operation going to do, the more possibility race condition happen</strong>).</p>
<h3>Atomicity example</h3>
<p>I wrote a Winform application, it do simple work:</p>
<p>Create 10 threads at runtime and simultaneously operates on a private interger, there is a volatile counter with initial value 0, every thread finishes its work will:</p>
<ol>
<li>Print information on UI.</li>
<li>Increment the counter</li>
<li>Check whether the counter reachs 10, if yes, print <code>CalculatingFinished</code> method which will print the final result.</li>
</ol>
<p>And I wish UI won't block during the calculation, otherwise I can simply join every created thread. My code skeleton is showing below:</p>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">const</span> <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">MaxThraedCount</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">10</span>;<br /> <span style="color: #8ac6f2;">private</span> <span style="color: #f6f3e8;">Thread</span><span style="color: #f6f3e8;">[]</span> <span style="color: #f6f3e8;">m_Workers</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">new</span> <span style="color: #f6f3e8;">Thread</span><span style="color: #f6f3e8;">[</span><span style="color: #f6f3e8;">MaxThraedCount</span><span style="color: #f6f3e8;">];</span><br /> <span style="color: #8ac6f2;">private</span> <span style="color: #f6f3e8;">volatile</span> <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">m_Counter</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<br /> <span style="color: #8ac6f2;">private</span> <span style="color: #f6f3e8;">Int32</span> <span style="color: #f6f3e8;">x</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<br /> <br /> <span style="color: #8ac6f2;">protected</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">btn_DoWork_Click</span>(<span style="color: #cae682;">object</span> <span style="color: #f6f3e8;">sender</span><span style="color: #f6f3e8;">,</span> <span style="color: #f6f3e8;">EventArgs</span> <span style="color: #f6f3e8;">e</span>)<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">ShowStatus</span>(<span style="color: #95e454; font-style: italic;">"Starting..."</span>);<br /> <br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #f6f3e8;">MaxThraedCount</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Workers</span><span style="color: #f6f3e8;">[</span><span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">]</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">new</span> <span style="color: #f6f3e8;">Thread</span>(<span style="color: #f6f3e8;">IncreaseNumber</span>) <span style="color: #f6f3e8;">{</span> <span style="color: #f6f3e8;">Name</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"Thread "</span> <span style="color: #f6f3e8;">+</span> (<span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">+</span> <span style="color: #e5786d;">1</span>) <span style="color: #f6f3e8;">};</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Workers</span><span style="color: #f6f3e8;">[</span><span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">].</span><span style="color: #f6f3e8;">Start</span>();<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> <span style="color: #f6f3e8;">}</span><br /> <br /> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">IncreaseNumber</span>()<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">try</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-style: italic; color: #ff0000; background-color: #333333;">// Different strategy to increment x</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">ShowStatus</span>(<span style="color: #f6f3e8;">String</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Format</span>(<span style="color: #95e454; font-style: italic;">"{0} finished at {1}"</span><span style="color: #f6f3e8;">,</span> <span style="color: #f6f3e8;">Thread</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">CurrentThread</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Name</span><span style="color: #f6f3e8;">,</span> <span style="color: #f6f3e8;">m_Watcher</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Elapsed</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">TotalMilliseconds</span>));<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #99968b; font-style: italic;">// Increases Counter and decides whether or not sets the finish signal</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Counter</span><span style="color: #f6f3e8;">++;</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">if</span> (<span style="color: #f6f3e8;">m_Counter</span> <span style="color: #f6f3e8;">==</span> <span style="color: #f6f3e8;">MaxThraedCount</span>)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #99968b; font-style: italic;">// Print finish information on UI</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">CalculatingFinished</span>();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Counter</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">catch</span> (<span style="color: #f6f3e8;">Exception</span> <span style="color: #f6f3e8;">ex</span>)<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">throw</span>;<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> <span style="color: #f6f3e8;">}</span><br /> <br /> <span style="color: #8ac6f2;">public</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">ShowStatus</span>(<span style="color: #cae682;">string</span> <span style="color: #f6f3e8;">info</span>)<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">this</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">InvokeAction</span>(() <span style="color: #f6f3e8;">=&gt;</span> <span style="color: #f6f3e8;">listInfo</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Items</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Add</span>(<span style="color: #f6f3e8;">info</span>));<br /> <span style="color: #f6f3e8;">}</span><br /> <br /> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">CalculatingFinished</span>()<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">ShowStatus</span>(<span style="color: #95e454; font-style: italic;">"\r\nAll Done at: "</span> <span style="color: #f6f3e8;">+</span> <span style="color: #f6f3e8;">m_Watcher</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Elapsed</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">TotalMilliseconds</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">ShowStatus</span>(<span style="color: #95e454; font-style: italic;">"The result: "</span> <span style="color: #f6f3e8;">+</span> <span style="color: #f6f3e8;">x</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">ToString</span>());<br /> <span style="color: #f6f3e8;">}</span></pre>
<p>I highlighted "<span style="color: #ff0000;">// Different strategy to increment x</span>", and will try a few number of ways to achieve atomicity using FCL libriries.</p>
<p>Let's first see the non-atomic routine - simple do <code>x++</code> in each thread:&nbsp;</p>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">x</span><span style="color: #f6f3e8;">++;</span><br /> <span style="color: #f6f3e8;">}</span></pre>
<p>Since <code>x++</code>&nbsp;is NOT atomicity, in additional, I made a large loop - 10 thousand times, in my experience, <strong>I NEVER get the correct result</strong>, the screenshot is below:</p>
<p><img title="Non-Atomic Operation" src="https://byfiles.storage.live.com/y1pQi3Nl0yapalU1nSyhn03OdJGdxqMU7fhvSn8pP2sMKSj2oarw3u0XP2Skce4IVx7ZKEp5t-bBpo/Non-Atomic%20Operation.png?psid=1" alt="Non-Atomic Operation" width="312" height="372" /></p>
<h3>Analysis and solutions</h3>
<p>To solve the issue and ensure atomicity, by more than 2 weeks brokenly study&nbsp;I found the following feasible ways (in theory, not considering performance):</p>
<ol>
<li><a href="http://msdn.microsoft.com/en-us/library/dd78zt0c.aspx" target="_blank">Interlocked.Increment</a></li>
<li>Apply exclusive lock (or&nbsp;Moniter.Enter) outside the for loop.</li>
<li>AutoResetEvent to ensure threads doing task one by one.&nbsp;</li>
<li>Create a temp integer in each thread and once finish add temp onto x under an exclusive lock.</li>
<li><a href="http://msdn.microsoft.com/en-us/library/system.threading.readerwriterlockslim.aspx" target="_blank">ReaderWriterLockSlim</a>.</li>
<li>Parallel.For coordinate with Interlocked.Increment.&nbsp;</li>
</ol>
<p>All of above can achieve atomic operation on incresing x's value, and got expected result:</p>
<p><img title="Atomic operation" src="https://byfiles.storage.live.com/y1pm5SIiPilGL46hWb1rtQFqFLnk588wS3FXBQhe8uNCPXB5b3rvWkVXQJinei1KFpOh9BBlwJa238/Atomic%20Operation.png?psid=1" alt="Atomic operation" width="312" height="372" /></p>
<p>In fact I did try other ways such as using MemoryBarrier, Thread.VolatileRead/VolatileWrite - <a href="http://stackoverflow.com/questions/7949440/how-to-use-memorybarrier-ways-to-safe-atomicity-operations" target="_blank">StackOverFlow question link</a>, but failed, if dear readers know there is way to use them to achieve the goal please kindly guide me. &nbsp;</p>
<h3>Demonstration code</h3>
<p>In this section I will listed key code for implementing the 5 solutions above.</p>
<h4>Solution #1:&nbsp;Interlocked.Increment</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Interlocked</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Increment</span>(<span style="color: #8ac6f2;">ref</span> <span style="color: #f6f3e8;">x</span>);</pre>
<h4>Solution #2:&nbsp;Apply exclusive lock (Moniter) outside the for loop.</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">readonly</span> <span style="color: #cae682;">string</span> <span style="color: #f6f3e8;">m_Locker</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"THREAD_LOCKER"</span>;<br /> <br /> <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Enter</span>(<span style="color: #f6f3e8;">m_Locker</span>);<br /> <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">x</span><span style="color: #f6f3e8;">++;</span><br /> <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Exit</span>(<span style="color: #f6f3e8;">m_Locker</span>);</pre>
<h4>Solution #3:&nbsp;AutoResetEvent to ensure threads doing task one by one.</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">static</span> <span style="color: #f6f3e8;">AutoResetEvent</span> <span style="color: #f6f3e8;">m_AutoReset</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">new</span> <span style="color: #f6f3e8;">AutoResetEvent</span>(<span style="color: #8ac6f2;">false</span>);<br /> <br /> <span style="color: #8ac6f2;">protected</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">btn_DoWork_Click</span>(<span style="color: #cae682;">object</span> <span style="color: #f6f3e8;">sender</span><span style="color: #f6f3e8;">,</span> <span style="color: #f6f3e8;">EventArgs</span> <span style="color: #f6f3e8;">e</span>)<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">ShowStatus</span>(<span style="color: #95e454; font-style: italic;">"Starting..."</span>);<br /> <br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #f6f3e8;">MaxThraedCount</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Workers</span><span style="color: #f6f3e8;">[</span><span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">]</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">new</span> <span style="color: #f6f3e8;">Thread</span>(<span style="color: #f6f3e8;">IncreaseNumber</span>) <span style="color: #f6f3e8;">{</span> <span style="color: #f6f3e8;">Name</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"Thread "</span> <span style="color: #f6f3e8;">+</span> (<span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">+</span> <span style="color: #e5786d;">1</span>) <span style="color: #f6f3e8;">};</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_Workers</span><span style="color: #f6f3e8;">[</span><span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">].</span><span style="color: #f6f3e8;">Start</span>();<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_AutoReset</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Set</span>();<br /> <span style="color: #f6f3e8;">}</span><br /> <br /> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">IncreaseNumber</span>()<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_AutoReset</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">WaitOne</span>();<br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">x</span><span style="color: #f6f3e8;">++;</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_AutoReset</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Set</span>();<br /> <span style="color: #f6f3e8;">}</span></pre>
<blockquote>
<p>One notable point is in this case (UI non-blocking) it is not easy to use Monitor.Enter/Monitor.Pulse pair to replace AutoResetEvent and implement "one by one" logic becasue Monitor.Pulse won't <strong>maitain state</strong>, below is the description in MSDN:</p>
<div class="alert">
<table style="width: 540px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p><strong>Important</strong></p>
</td>
</tr>
<tr>
<td valign="top">
<p>The&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.monitor.aspx">Monitor</a>&nbsp;class does not maintain state indicating that the&nbsp;Pulse&nbsp;method has been called. Thus, if you call&nbsp;Pulse&nbsp;when no threads are waiting, the next thread that calls&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.monitor.wait.aspx">Wait</a>&nbsp;blocks as if&nbsp;Pulse&nbsp;had never been called. If two threads are using&nbsp;Pulse&nbsp;and&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.monitor.wait.aspx">Wait</a>&nbsp;to interact, this could result in a deadlock. Contrast this with the behavior of the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.autoresetevent.aspx">AutoResetEvent</a>&nbsp;class: If you signal an&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.autoresetevent.aspx">AutoResetEvent</a>&nbsp;by calling its&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.eventwaithandle.set.aspx">Set</a>&nbsp;method, and there are no threads waiting, the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.autoresetevent.aspx">AutoResetEvent</a>&nbsp;remains in a signaled state until a thread calls&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.waithandle.waitone.aspx">WaitOne</a>,&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.waithandle.waitany.aspx">WaitAny</a>, or&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.waithandle.waitall.aspx">WaitAll</a>. The&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.threading.autoresetevent.aspx">AutoResetEvent</a>&nbsp;releases that thread and returns to the unsignaled state.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="alert"><br />In my Winform application, if I call Monitor.Pulse() in button click event, many threads will not receive the signal (whereas AutoResetEvent will remain signaled state)! I wrote a simple routine to demonstrate this:</div>
<pre class="source" style="width: 580px; font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">static</span> <span style="color: #8ac6f2;">readonly</span> <span style="color: #cae682;">string</span> <span style="color: #f6f3e8;">_locker</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"THREAD_LOCKER"</span>;<br /> <span style="color: #8ac6f2;">public</span> <span style="color: #8ac6f2;">static</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">Main</span>()<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span>(<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">&lt;</span><span style="color: #e5786d;">5</span>;<span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Thread</span> <span style="color: #f6f3e8;">t</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">new</span> <span style="color: #f6f3e8;">Thread</span>(<span style="color: #f6f3e8;">DoWork</span>);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">t</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Name</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"T"</span> <span style="color: #f6f3e8;">+</span> (<span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">+</span> <span style="color: #e5786d;">1</span>);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">t</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">IsBackground</span> <span style="color: #f6f3e8;">=</span> <span style="color: #8ac6f2;">true</span>;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">t</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Start</span>();<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">}</span><br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; <span style="color: #99968b; font-style: italic;">//Thread.Sleep(500);</span><br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Enter</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Console</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">WriteLine</span>(<span style="color: #95e454; font-style: italic;">"Main thread"</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Pulse</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Exit</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> <span style="color: #f6f3e8;">}</span><br /> <br /> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">static</span> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">DoWork</span>()<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Enter</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Wait</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Pulse</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Monitor</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Exit</span>(<span style="color: #f6f3e8;">_locker</span>);<br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">Console</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">WriteLine</span>(<span style="color: #f6f3e8;">Thread</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">CurrentThread</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Name</span> <span style="color: #f6f3e8;">+</span> <span style="color: #95e454; font-style: italic;">" finished and exist"</span>);<br /> <span style="color: #f6f3e8;">}</span></pre>
Removing "<code>Thread.Sleep(500)</code>" will *<strong>VERY POSSIBLY</strong>* lead less than 5 thread working, because creating 5 threads requires not short time (kenel object, TEB, kenel/user stack), during the period one just created thread (T2) might get the signal or <strong>might not</strong> (<strong>much more possible</strong>), because when the previously created thread (T1) calling "Monitor.Pulse(_locker)" T2 had NOT been setup, T2 and the thread created later <strong>will have no chance to get signal</strong>! They will be waiting... So the 0.5 seconds is used to give time to create 5 thread, otherwise main thread will quit immediately and background thread will be collected.</blockquote>
<h4>Solution #4:&nbsp;Create a temp integer in each thread and once finish add temp onto x under a exclusive lock.</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">private</span> <span style="color: #8ac6f2;">readonly</span> <span style="color: #cae682;">string</span> <span style="color: #f6f3e8;">m_Locker</span> <span style="color: #f6f3e8;">=</span> <span style="color: #95e454; font-style: italic;">"THREAD_LOCKER"</span>;<br /> <br /> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">IncreaseNumber</span>(<span style="color: #cae682;">object</span> <span style="color: #f6f3e8;">objThreadName</span>)<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">tmp</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>;<br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">tmp</span><span style="color: #f6f3e8;">++;</span><br /> <br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">lock</span> (<span style="color: #f6f3e8;">m_Locker</span>)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">x</span> <span style="color: #f6f3e8;">+=</span> <span style="color: #f6f3e8;">tmp</span>;<br /> <span style="color: #f6f3e8;">}</span></pre>
<h4>Solution #5:&nbsp;ReaderWriterLockSlim.</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #8ac6f2;">void</span> <span style="color: #cae682;">IncreaseNumber</span>(<span style="color: #cae682;">object</span> <span style="color: #f6f3e8;">objThreadName</span>)<br /> <span style="color: #f6f3e8;">{</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #99968b; font-style: italic;">// Or we can use ReaderWriterLock.AcquireWriterLock(500) but it has more performance overhead and is not recommended</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_ReaderWriterLocker</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">EnterWriteLock</span>(); <br /> &nbsp;&nbsp;&nbsp; <span style="color: #8ac6f2;">for</span> (<span style="color: #cae682;">int</span> <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">=</span> <span style="color: #e5786d;">0</span>; <span style="color: #f6f3e8;">i</span> <span style="color: #f6f3e8;">&lt;</span> <span style="color: #e5786d;">10000</span>; <span style="color: #f6f3e8;">i</span><span style="color: #f6f3e8;">++)</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">x</span><span style="color: #f6f3e8;">++;</span><br /> &nbsp;&nbsp;&nbsp; <span style="color: #f6f3e8;">m_ReaderWriterLocker</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">ExitWriteLock</span>();&nbsp; <span style="color: #99968b; font-style: italic;">// Or ReaderWriterLock.ReleaseWriterLock();</span><br /> <span style="color: #f6f3e8;">}</span></pre>
<blockquote>
<p>Please note that ReaderWriterLock class is not recommended, it "take about five times longer to execute than a call to Monitor's Enter method." please refer:&nbsp;<a href="http://msdn.microsoft.com/zh-cn/magazine/cc163599(en-us).aspx" target="_blank">Reader/Writer Locks and the ResourceLock Library</a> by Jeffery Richter.</p>
</blockquote>
<h4>Solution #6:&nbsp;Parallel.Forcoordinate with Interlocked.Increment.</h4>
<pre class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f6f3e8; background-color: #242424;"> <span style="color: #f6f3e8;">Parallel</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">For</span>(<span style="color: #e5786d;">0</span><span style="color: #f6f3e8;">,</span> <span style="color: #e5786d;">100000</span><span style="color: #f6f3e8;">,</span> (<span style="color: #f6f3e8;">i</span>) <span style="color: #f6f3e8;">=&gt;</span> <span style="color: #f6f3e8;">Interlocked</span><span style="color: #f6f3e8;">.</span><span style="color: #f6f3e8;">Increment</span>(<span style="color: #8ac6f2;">ref</span> <span style="color: #f6f3e8;">x</span>));</pre>
<h3>Conclusion</h3>
<p>In this post I took a simple &amp; straight-forward example: 10 threads simultaneously operating on on field, to experiment atomicity operation in C#.Net, using synchronization technology including exclusive locking, signaling, non-blocking synchronization, I guess this is a very good example to master basic FCL thread libraries/concepts such as <strong>Interlocked</strong>, <strong>Monitor</strong>, <strong>MemoryBarrier</strong>, <strong>volatile</strong>, <strong>AutoResetEvent</strong>, <strong>ReaderWriterLockSlim</strong>, etc.</p>
<p>Multi-threading programming is indeed very complex, during my investigation I happened to saw even Jon Skeet admitted he had &ldquo;his eyes opened to the precise meaning of volatile which isn't "always read from main memory, always write directly to main memory" (<a href="http://stackoverflow.com/questions/2005211/when-to-use-lock-vs-memorybarrier-in-net#2005237" target="_blank">link</a>), so as a&nbsp;rookie in this field I should invest more effort on it:)</p>
<h3>Further Reading</h3>
<p><a href="http://www.albahari.com/threading/" target="_blank">Threading In C#</a>&nbsp;(Strongly recommended!!!)</p>
<p><a href="http://en.wikipedia.org/wiki/Atomic_operation" target="_blank">Linearizability</a>&nbsp;Wikipedia</p>
<p><a href="http://www.bluebytesoftware.com/blog/PermaLink,guid,c4ea3d6d-190a-48f8-a677-44a438d8386b.aspx" target="_blank">Introducing the new ReaderWriterLockSlim in Orcas</a></p>
<p><a href="http://www.codeproject.com/KB/cs/AsynchronousCodeBlocks.aspx" target="_blank">Asynchronous Code Blocks</a></p>
<p><a href="http://odetocode.com/blogs/scott/archive/2006/05/17/atomic-operations.aspx" target="_blank">Atomic Operations</a></p>
<p><a href="http://drdobbs.com/visualstudio/226900048" target="_blank">Boosting Performance with Atomic Operations in .NET 4</a></p>
